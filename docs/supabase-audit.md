# Audit Supabase

## Résumé de l'installation actuelle
- Le projet embarque les packages Supabase côté client (`@supabase/supabase-js`) et les aides Next.js (`@supabase/ssr`, `@supabase/auth-helpers-nextjs`, `@supabase/auth-helpers-react`).【F:package.json†L11-L58】
- Le client navigateur est construit via `createBrowserClient` et mis en cache dans `src/lib/supabase/client.ts`, avec des utilitaires pour vider le stockage local et réinitialiser l'instance.【F:src/lib/supabase/client.ts†L1-L40】
- Le layout racine crée un client serveur Supabase pour récupérer l'utilisateur courant et sa souscription, mais désactive l'écriture des cookies côté serveur.【F:src/app/layout.tsx†L8-L77】
- Les composants client sont enveloppés d'un `SupabaseProvider` qui expose une instance partagée du client navigateur, et le `UserProvider` synchronise l'état utilisateur via `auth.getSession()` et `onAuthStateChange`.【F:src/components/ClientLayout.tsx†L30-L39】【F:src/components/SupabaseProvider.tsx†L1-L27】【F:src/context/UserContext.tsx†L1-L77】
- Le middleware Next s'appuie sur `createMiddlewareClient` pour protéger les routes privées via l'utilisateur Supabase et certains cookies de consentement.【F:middleware.ts†L1-L58】
- Les route handlers sensibles (`/api/delete-account` par exemple) utilisent le service role key côté serveur pour effectuer des opérations privilégiées et manipulent correctement les cookies Supabase côté serveur.【F:src/app/api/delete-account/route.ts†L1-L114】

## Points positifs
1. **Séparation claire client / serveur** : le code distingue correctement les clients Supabase pour le navigateur, le middleware et le serveur, ce qui limite les risques d'exposer la clé de service.【F:src/lib/supabase/client.ts†L1-L40】【F:src/app/api/delete-account/route.ts†L1-L114】
2. **Contexte React dédié** : `SupabaseProvider` évite la recréation d'instances, et `UserProvider` gère l'état d'authentification de façon centralisée via les callbacks Supabase.【F:src/components/SupabaseProvider.tsx†L1-L27】【F:src/context/UserContext.tsx†L1-L77】
3. **Protection middleware** : l'utilisation de `createMiddlewareClient` permet d'appliquer une logique d'accès homogène sur des routes critiques, en tenant compte des consentements stockés côté cookie.【F:middleware.ts†L1-L58】
4. **Opérations admin sécurisées** : les handlers sensibles vérifient la présence des trois variables d'environnement et n'utilisent le service role key que côté serveur Node.js.【F:src/app/api/delete-account/route.ts†L21-L114】

## Problèmes et risques identifiés
1. **Absence de validations d'environnement au build** : plusieurs appels utilisent `process.env.NEXT_PUBLIC_SUPABASE_URL!` et `process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!` avec des assertions non nulles. Si une variable est manquante à l'exécution, le code plantera tardivement sans message clair. Cela touche le client navigateur, le layout SSR et divers handlers.【F:src/lib/supabase/client.ts†L7-L15】【F:src/app/layout.tsx†L41-L77】
2. **Cookies non mis à jour dans le layout SSR** : dans `RootLayout`, les méthodes `set` et `remove` du cookie store sont volontairement vides. Cela empêche Supabase de rafraîchir un token expiré lors du rendu SSR, ce qui peut provoquer des déconnexions silencieuses ou des sessions non rafraîchies pour les utilisateurs actifs.【F:src/app/layout.tsx†L41-L53】
3. **Réutilisation du client en dehors du provider** : certains composants créent eux-mêmes une instance (ex. `src/app/admin/offer-shop/page.tsx`). Même si l'instance est globalement mémorisée, cela contourne le provider et complique la gestion de contexte ou d'effets globaux comme la traçabilité des erreurs.【F:src/app/admin/offer-shop/page.tsx†L1-L120】
4. **Logs sensibles en production** : le middleware et certains composants loguent les chemins visités et l'état d'authentification dans la console (`console.log('[mw] isAuth=...')`). Ces logs, combinés aux identifiants, peuvent exposer des informations sensibles en production.【F:middleware.ts†L10-L16】【F:src/components/ClientLayout.tsx†L15-L26】
5. **Dépendance aux cookies de consentement pour l'accès** : la vérification `hasClientConsent` s'appuie sur des cookies `sb-remember` et `sb-session-tab`. Sans fallback, un utilisateur authentifié côté serveur mais sans ces cookies sera redirigé. Si ces cookies ne sont pas définis par défaut ou expirent, cela peut provoquer des redirections indésirables.【F:middleware.ts†L18-L47】

## Recommandations d'amélioration
1. **Valider les variables Supabase au démarrage** : centraliser la vérification dans un module (par exemple `lib/supabase/config.ts`) qui lève une erreur explicite si une variable est absente. Cette validation peut également être ajoutée à un script `postinstall` ou `lint` pour détecter rapidement les mauvaises configurations.【F:src/lib/supabase/client.ts†L7-L15】【F:src/app/layout.tsx†L41-L53】
2. **Permettre la mise à jour des cookies SSR** : adapter `RootLayout` pour propager les écritures de cookies (utiliser `cookies()` de Next 15 côté RSC n'est pas supporté, mais on peut basculer la récupération du profil utilisateur dans un Server Action ou un Route Handler qui renvoie les données au layout). Alternativement, créer un utilitaire serveur dédié (ex. `getUserWithSession()`) exécuté dans une Route Handler `GET` qui renvoie les données au layout via `fetch` côté serveur.【F:src/app/layout.tsx†L41-L77】
3. **Encapsuler l'accès client dans des hooks** : au lieu d'appeler `createClient()` directement dans les composants, exposer un hook `useSupabase()` (déjà fourni) ou un helper de service pour conserver une couche d'abstraction unique et appliquer plus facilement des middlewares (logging, instrumentation).【F:src/components/SupabaseProvider.tsx†L1-L27】【F:src/app/admin/offer-shop/page.tsx†L1-L120】
4. **Nettoyer les logs de production** : prévoir une stratégie conditionnelle (`if (process.env.NODE_ENV === 'development')`) ou un utilitaire de logging qui masque les données sensibles avant de les écrire, notamment dans le middleware et les composants partagés.【F:middleware.ts†L10-L16】【F:src/components/ClientLayout.tsx†L15-L26】
5. **Clarifier la logique de consentement** : documenter et tester la mise en place des cookies `sb-remember` et `sb-session-tab`, ou fournir un fallback pour les utilisateurs authentifiés sans consentement explicite (par exemple en affichant une bannière de consentement côté client plutôt qu'un blocage middleware).【F:middleware.ts†L24-L47】
6. **Surveiller les opérations admin** : même si le service role est protégé, envisager d'ajouter de l'audit logging (ex. via Supabase Edge Functions ou un système externe) pour toute suppression de compte, afin d'avoir une traçabilité si la clé fuit ou est mal utilisée.【F:src/app/api/delete-account/route.ts†L64-L114】

## Recommandations d'optimisation
1. **Mutualiser les accès aux données côté serveur** : déplacer les requêtes volumineuses (comme le listing `offer_shop`) vers des Route Handlers ou Server Components pour profiter du streaming et éviter de recharger l'intégralité des données au montage client. Le layout ou les pages pourraient alors consommer une réponse déjà filtrée et paginée.【F:src/app/admin/offer-shop/page.tsx†L1-L120】【F:src/app/layout.tsx†L41-L77】
2. **Mettre en place une pagination native Supabase** : `fetchOffers` récupère actuellement l'ensemble des résultats sans limite. Utiliser `range` ou `limit/offset` réduirait les transferts de données et améliorerait la latence sur de gros volumes, tout en facilitant le rendu incrémental côté client.【F:src/app/admin/offer-shop/page.tsx†L55-L111】
3. **Réutiliser la session partagée du `UserProvider`** : les appels explicites à `supabase.auth.getSession()` pourraient lire la session déjà hydratée dans le contexte pour éviter des allers-retours réseau au montage et accélérer l'affichage initial des pages protégées.【F:src/app/admin/offer-shop/page.tsx†L43-L78】【F:src/context/UserContext.tsx†L1-L77】
4. **Normaliser les requêtes côté client** : extraire les accès répétitifs à `supabase.from("offer_shop")` dans un service dédié afin d'appliquer des sélections de colonnes strictes, un cache mémoire léger ou un mécanisme de révalidation automatique (`revalidatePath`) pour limiter les charges inutiles et partager les résultats entre composants.【F:src/app/admin/offer-shop/page.tsx†L55-L134】

## Pistes complémentaires
- Ajouter des tests d'intégration ou des checks e2e (Playwright) pour garantir que les flux auth (inscription, connexion, rafraîchissement de session) restent fonctionnels après mise à jour des dépendances Supabase.
- Mettre en place un script de rotation automatique des clés Supabase (service role et anon) si le projet manipule des données sensibles, et limiter leur exposition dans l'interface d'administration.
